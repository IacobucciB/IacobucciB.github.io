<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-06-28 vie. 15:03 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CDyM-TP1</title>
<meta name="author" content="IacobucciB" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">CDyM-TP1</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org77be47b">1. Control de periféricos LED externos con puertos de entrada/salida</a></li>
<li><a href="#org463dceb">2. Conexión de los LEDs</a>
<ul>
<li><a href="#org0545b89">2.1. Enunciado</a></li>
<li><a href="#org085332d">2.2. Interpretación</a></li>
<li><a href="#org32cf24d">2.3. Resolución</a></li>
</ul>
</li>
<li><a href="#org247e9c9">3. Conexión del Pulsador</a>
<ul>
<li><a href="#orgcdbfea9">3.1. Enunciado</a></li>
<li><a href="#org10356a5">3.2. Interpretación</a></li>
<li><a href="#org70d2fed">3.3. Resolución</a></li>
</ul>
</li>
<li><a href="#org685e426">4. Secuencia de Encendido</a>
<ul>
<li><a href="#orgb0b94ca">4.1. Enunciado</a></li>
<li><a href="#orgc477c1a">4.2. Interpretación</a></li>
<li><a href="#org2c94c43">4.3. Resolución</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org77be47b" class="outline-2">
<h2 id="org77be47b"><span class="section-number-2">1.</span> Control de periféricos LED externos con puertos de entrada/salida</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://github.com/IacobucciB/CDyM-TP1-2024-G1-LEDs">Link al Repositorio</a><br />
</p>
</div>
</div>

<div id="outline-container-org463dceb" class="outline-2">
<h2 id="org463dceb"><span class="section-number-2">2.</span> Conexión de los LEDs</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org0545b89" class="outline-3">
<h3 id="org0545b89"><span class="section-number-3">2.1.</span> Enunciado</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Se desea conectar 8 diodos LED de diferentes colores al puerto B del MCU y encenderlos con una corriente de 10mA en cada uno. Realice el esquema eléctrico de la conexión en Proteus. Calcule la resistencia serie para cada color teniendo en cuenta la caída de tensión VLED (rojo=1.8V, verde=2.2V, amarillo=2.0V, azul=3.0V). Verifique que la corriente por cada terminal del MCU no supere la capacidad de corriente de cada salida y de todas las salidas del mismo puerto en funcionamiento simultáneo.<br />
</p>
</div>
</div>

<div id="outline-container-org085332d" class="outline-3">
<h3 id="org085332d"><span class="section-number-3">2.2.</span> Interpretación</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Dado el microcontrolador ATmega328P, se debe conectar 8 diodos LED de 4 diferentes colores (rojo, verde, amarillo y azul) al su puerto B. Para esto se calcularán las resistencias necesarias, teniendo como dato la corriente que circula por cada uno de los LEDS (10mA) y la caída de tensión de cada que varía dependiendo el color. Teniendo en cuenta la tensión de salida del microcontrolador, es crucial asegurar que la corriente a través de cada terminal del no exceda su capacidad máxima de corriente de salida, así como también verificar que la suma de las corrientes en todas las salidas del puerto B no supere la capacidad máxima total. Por último, se debe realizar un esquema eléctrico en Proteus de la conexión pedida utilizando los LEDS y las resistencias calculadas.<br />
</p>
</div>
</div>

<div id="outline-container-org32cf24d" class="outline-3">
<h3 id="org32cf24d"><span class="section-number-3">2.3.</span> Resolución</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Para el cálculo de cada una de las resistencias se utilizaron los siguientes datos:<br />
</p>

<ul class="org-ul">
<li>Caída de Tensión de cada LED<br />
<ul class="org-ul">
<li>Rojo = 1.8V<br /></li>
<li>Verde = 2.2V<br /></li>
<li>Amarillo = 2.0V<br /></li>
<li>Azul = 3.0V<br /></li>
</ul></li>
<li>Intensidad de corriente nominal (corriente que circula por cada LED), 10mA.<br /></li>
<li>Tensión de salida del Microcontrolador (4.75 V).<br /></li>
</ul>

<p>
La tensión de salida del Microcontrolador se obtuvo mirando la figura extraída de la hoja de datos correspondiente al MCU “Voltajes de salida en pines de entrada/salida y Corriente (Vcc = 5V)”. Se tomó un valor aproximado de 4.75 V ya que la corriente es de 10mA y suponiendo una temperatura ambiente de 25°C.<br />
</p>

<p>
<img src="./images/image14.png" alt="image14.png" /><br />
VOH vs IOH<br />
</p>

<p>
<img src="./images/image18.png" alt="image18.png" /><br />
PULL-UP<br />
</p>

<p>
Sabiendo por ley de Ohm que \( R_{\text{LED}} = \frac{V_{\text{OH}} - V_{\text{LED}}}{I_{\text{OH}}} \), calculamos:<br />
</p>

<p>
\[ R_{\text{rojo}} = \frac{4.75\text{V} - 1.8\text{V}}{10\text{mA}} = 295\Omega \]<br />
</p>

<p>
\[ R_{\text{verde}} = \frac{4.75\text{V} - 2.2\text{V}}{10\text{mA}} = 255\Omega \]<br />
</p>

<p>
\[ R_{\text{amarillo}} = \frac{4.75\text{V} - 2.0\text{V}}{10\text{mA}} = 275\Omega \]<br />
</p>

<p>
\[ R_{\text{azul}} = \frac{4.75\text{V} - 3.0\text{V}}{10\text{mA}} = 175\Omega \]<br />
</p>

<p>
Se debe verificar que la corriente por cada terminal del MCU no supere la capacidad de corriente de cada salida. Para ello, vemos que en la hoja de datos del microcontrolador ATmega328p, más precisamente de la sección 28.1 “Absolute Maximum Ratings”, nos dice que la corriente máxima de salida individual es de 40mA, cuyo valor es menor a los 10mA utilizados.<br />
</p>

<p>
Además, sabemos que la corriente total que circula por el puerto B en caso de que los 8 LEDS estén encendidos al mismo tiempo sería de 80mA, valor que es menor a los límites establecidos (100mA y 150mA) especificados en la sección 28.2 “DC Characteristics” de la hoja de datos.<br />
</p>

<p>
<img src="./images/image17.png" alt="image17.png" /><br />
LEDs<br />
</p>

<p>
Los valores de las resistencias nominales serían para:<br />
</p>

<ul class="org-ul">
<li>Led rojo : 330<br /></li>
<li>Led verde: 270<br /></li>
<li>Led amarillo: 330<br /></li>
<li>Led azul: 180<br /></li>
</ul>

<p>
De esta forma nos aseguramos que los valores de corriente estén por debajo de los 10mA, siendo resistencias lo suficientemente cercanas a las ideales calculadas previamente.<br />
</p>

<p>
<img src="./images/image20.png" alt="image20.png" /><br />
Resistores<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org247e9c9" class="outline-2">
<h2 id="org247e9c9"><span class="section-number-2">3.</span> Conexión del Pulsador</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgcdbfea9" class="outline-3">
<h3 id="orgcdbfea9"><span class="section-number-3">3.1.</span> Enunciado</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Se desea conectar un pulsador a una entrada digital del MCU y detectar cuando el usuario presiona y suelta el pulsador. Muestre el esquema de conexión y determine la configuración del MCU que corresponda. Investigue sobre el efecto de rebote que producen los pulsadores e implemente un método para eliminar este efecto en su algoritmo de detección (puede encontrar información útil en la bibliografía).<br />
</p>
</div>
</div>

<div id="outline-container-org10356a5" class="outline-3">
<h3 id="org10356a5"><span class="section-number-3">3.2.</span> Interpretación</h3>
<div class="outline-text-3" id="text-3-2">
<p>
En este ejercicio se debe mostrar el esquema de conexión usado para conectar un pulsador al microcontrolador. Se debe desarrollar un código de programa que detecte cuando se oprime y se suelta el pulsador, como así también un método para eliminar el efecto rebote, que se produce al hacer falsos contactos en el interruptor.<br />
</p>
</div>
</div>

<div id="outline-container-org70d2fed" class="outline-3">
<h3 id="org70d2fed"><span class="section-number-3">3.3.</span> Resolución</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Existen dos maneras de conectar un pulsador a una entrada del MCU:<br />
</p>

<ol class="org-ol">
<li>La primera es conectar el pulsador a Vcc y una resistencia pull-down en la otra parte, es decir como se ve en la figura 2. Lo que hace esto es dar un valor bajo en caso que el pulsador esté sin presionar y un valor alto en caso contrario.<br /></li>
<li>La segunda forma de conectar al pulsador es inversa a la mencionada anteriormente, el pulsador es conectado a GND y se utiliza una resistencia pull-up, como se ve en la figura 3. En este caso, cuando el pulsador no esté presionado se tiene un valor alto, y un valor bajo cuando lo esté.<br /></li>
</ol>

<p>
<img src="./images/image15.png" alt="image15.png" /><br />
Pull-up Interno<br />
</p>

<p>
En la práctica usaremos la configuración con la resistencia pull-up, ya que el microcontrolador ATmega328P cuenta con este tipo de resistencias integradas. Por lo que se debe conectar el pulsador a GND y activar el pull-up interno, y así evitamos tener que añadir una resistencia adicional.<br />
</p>

<p>
Para conectar el pulsador al microcontrolador usamos el pin 0 del puerto C como entrada.<br />
</p>

<p>
Cuando se conecta un pulsador puede producirse lo que se conoce como efecto rebote. Lo que hace este efecto es que cuando se presiona o suelta el pulsador se produce una variación en la señal en la que alterna entre el valor alto y bajo. Esta variación puede afectar en la ejecución correcta del programa ya que devuelve valores erróneos a los esperados.<br />
</p>

<p>
<img src="./images/image22.png" alt="image22.png" /><br />
Rebote<br />
</p>

<p>
Para resolver este problema, se pueden usar tanto técnicas de hardware como de software. Aquí utilizaremos una técnica por software que consiste en buscar N lecturas secuenciales estables del interruptor, donde N es un número que va desde 1 (sin ningún rebote) hasta aparentemente infinito. Generalmente, el código detecta una transición y luego comienza a incrementar o disminuir un contador, releyendo cada vez la entrada, hasta que N alcanza un conteo presumiblemente seguro y sin rebotes. Si el estado no es estable, el contador se reinicia a su valor inicial.<br />
</p>

<p>
<img src="./images/image12.png" alt="image12.png" /><br />
Polling<br />
</p>

<p>
Esto último en pseudocódigo quedaría:<br />
</p>

<pre class="example">
CONSTANTES:
- Intervalo de lectura del hardware en milisegundos
- Tiempo mínimo estable para considerar una tecla como presionada
- Tiempo mínimo estable para considerar una tecla como liberada

FUNCIÓN para manejar el antirrebote de la tecla:
    Crear un contador para el tiempo de estabilización
    Inicializar valores de salida de la función
    Si el estado del pin coincide con el estado antirrebote actual
        Actualizar el temporizador según el estado actual
    Sino
        Si Temporizador expirado
            Aceptar cambio de estado
            Restablecer el temporizador según el nuevo estado
FIN FUNCIÓN
</pre>
</div>
</div>
</div>

<div id="outline-container-org685e426" class="outline-2">
<h2 id="org685e426"><span class="section-number-2">4.</span> Secuencia de Encendido</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgb0b94ca" class="outline-3">
<h3 id="orgb0b94ca"><span class="section-number-3">4.1.</span> Enunciado</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Realice el programa para que el MCU encienda los LEDs del puerto B con la siguiente secuencia de encendido repetitiva: b0 y b7 – b1 y b6 – b2 y b5 – b3 y b4. Luego, cuando el usuario presione y suelte el pulsador debe cambiar a la secuencia: b7-b6-b5-b4-b3-b2-b1-b0. Si presiona y suelta nuevamente vuelve a la secuencia original y así sucesivamente. Dibuje el diagrama de flujo y el esquema de conexión completo en Proteus.<br />
</p>
</div>
</div>

<div id="outline-container-orgc477c1a" class="outline-3">
<h3 id="orgc477c1a"><span class="section-number-3">4.2.</span> Interpretación</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Este ejercicio busca escribir un programa que permita realizar secuencias de encendido de LEDs según se indica. El pulsador debe cambiar la secuencia de encendido. Para desarrollar el ejercicio se tendrá en cuenta la configuración previa de los LEDS en puerto B y del pulsador en el puerto C.<br />
</p>
</div>
</div>

<div id="outline-container-org2c94c43" class="outline-3">
<h3 id="org2c94c43"><span class="section-number-3">4.3.</span> Resolución</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Para el desarrollo del código primero se debe considerar la inicialización de los puertos de entrada y salida, y luego la implementación de la secuencia deseada.<br />
</p>

<p>
La secuencia deseada en el enunciado tiene dos partes, la primera en la cual se deben prender dos LEDs a la vez en el orden especificado, y la segunda parte que consiste en prender un solo LED desde la posición 7 a la 0.<br />
</p>

<p>
Diagrama de flujo:<br />
</p>

<p>
<img src="./images/image10.png" alt="image10.png" /><br />
Diagrama de Flujo<br />
</p>

<p>
Para llevar a cabo el desarrollo del código en C se utiliza la estructura de datos estados, como se ve en el pseudocódigo:<br />
</p>

<pre class="example">
INICIALIZACIÓN
    Definir puertos de entrada y salida
    Inicializar LEDS apagados
    Inicializar Estado Inicial

LOOP PRINCIPAL
    Si pulsador presionado y liberado
        Cambiar Estado de Secuencia
    Fin Si
    Ejecutar Secuencia
FIN LOOP
</pre>


<p>
<img src="./images/image9.png" alt="image9.png" /><br />
Simulación en Proteus<br />
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: IacobucciB</p>
<p class="date">Created: 2024-06-28 vie. 15:03</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
